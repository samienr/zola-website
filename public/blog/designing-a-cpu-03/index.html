<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta content="Electrical Nerd + Digital Artist" name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content="rgb(101, 143, 239)" name=theme-color><meta content="rgb(140, 170, 238)" media=(prefers-color-scheme:dark) name=theme-color><title>Designing a CPU From Scratch, Part 3: Datapath - samienr</title><link href=https://samienr.com/blog/designing-a-cpu-03/ rel=canonical><link href=https://samienr.com/favicon.png rel=icon type=image/png><link href=https://samienr.com/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><link title="samienr - RSS Feed" href=https://samienr.com/rss.xml rel=alternate type=application/rss+xml><link title="samienr - Atom Feed" href=https://samienr.com/atom.xml rel=alternate type=application/atom+xml><style>:root{--accent-color:#658fef}[data-theme=dark]{--accent-color:#8caaee}@media (prefers-color-scheme:dark){:root:not([data-theme=light]){--accent-color:#8caaee}}</style><link href=https://samienr.com/style.css rel=stylesheet><link href=https://samienr.com/footer.css rel=stylesheet><link href=https://samienr.com/typography.css rel=stylesheet><link href=https://samienr.com/notebook.css rel=stylesheet><script defer src=https://samienr.com/closable.js></script><script defer src=https://samienr.com/copy-button.js></script><script data-goatcounter=https://samienr.goatcounter.com/count defer src=https://samienr.com/count.js></script><script defer src=https://samienr.com/elasticlunr.min.js></script><script defer src=https://samienr.com/search-elasticlunr.js></script><script defer src=https://samienr.com/theme-switcher.js></script><meta content=samienr property=og:site_name><meta content="Designing a CPU From Scratch, Part 3: Datapath - samienr" property=og:title><meta content=https://samienr.com/blog/designing-a-cpu-03/ property=og:url><meta content="The machine's musculoskeletal system" property=og:description><meta content=https://samienr.com/card.png property=og:image><meta content=en_US property=og:locale><body><header id=site-nav><nav><a href=#main-content tabindex=0> Skip to Main Content </a><ul><li id=home><a href=https://samienr.com> <i class=icon></i>samienr</a><li class=divider><li><a href=https://samienr.com/blog/>Blog</a><li><a href=https://samienr.com/photography/>Photography</a><li><a href=https://samienr.com/contact/>Contact</a><li id=search><button class=circle id=search-toggle title=Search><i class=icon></i></button><li id=theme-switcher><details class=closable><summary class=circle title=Theme><i class=icon></i></summary> <ul><li><button title="Switch to Light Theme" class=circle id=theme-light><i class=icon></i></button><li><button title="Switch to Dark Theme" class=circle id=theme-dark><i class=icon></i></button><li><button title="Use System Theme" class=circle id=theme-system><i class=icon></i></button></ul></details><li id=feed><details class=closable><summary class=circle title=Feed><i class=icon></i></summary> <ul><li><a href=https://samienr.com/rss.xml>RSS</a><li><a href=https://samienr.com/atom.xml>Atom</a></ul></details></ul></nav><div id=search-container><label class=visually-hidden for=search-bar>Search</label><input placeholder="Search for…" autocomplete=off disabled id=search-bar type=search><div id=search-results-container><div id=search-results></div></div></div></header><main id=main-content><div id=breadcrumb-container><a class=breadcrumb-path href=/>Home</a><span class=breadcrumb-separator> > </span><a class=breadcrumb-path href=https://samienr.com/blog/>Blog</a><span class=breadcrumb-separator> > </span><a class="breadcrumb-path active" id=active-page>Designing a CPU From Scratch, Part 3: Datapath</a></div><article><div id=heading><p><small> <time datetime=" 2025-12-29T00:00:00+00:00">Published on December 29, 2025</time></small><h1>Designing a CPU From Scratch, Part 3: Datapath</h1><p><small><span>10 minutes read</span><span> • </span></small><ul class=tags><li><a class=tag href=https://samienr.com/tags/projects/>Projects</a><li><a class=tag href=https://samienr.com/tags/computer-architecture/>Computer Architecture</a><li><a class=tag href=https://samienr.com/tags/designing-a-cpu/>Designing a CPU</a></ul></div><div id=buttons-container><a title="Go to Top" href=#top id=go-to-top><i class=icon></i></a><a title="File an Issue" href=https://github.com/samienr/zola-website/issues id=issue><i class=icon></i></a></div><p>Last time, we finished off with a very barebones set of components for our RISC-V core. Now we can begin with the first half of most interesting part of this process: connecting the datapath and creating the control signals.<p>Microarchitectures are typically divided into two parts: a datapath and a control unit. The datapath consists of structures that hold the architectural state of the machine (like those we made in Part 2 of these blogs). It also houses a bunch of combinational logic which is used to process that state information and create new state information for the next state. This is what we will be making in this blog entry.<p>This is all driven by the control unit, which receives state information from the datapath, then tells the datapath what to do using control signals, such as write enables, mux selectors, and any other "decisions" our datapath logic has to make. We will figure out what control signals we need in Part 4 after creating the datapath.<p>We will begin by putting together the components we made last time, in addition to making some smaller components that will be needed to make these connections. In the next part we will create a set of control signals and a control unit to assert appropriate signals for each instruction.<h1 id=pipeline-registers>Pipeline Registers</h1><p>Let's start by taking a look at the components we made in <a href=https://samienr.com/blog/designing-a-cpu-02/>Part 2</a>.<figure><img src=basicComponents.png><figcaption>The components we made in Part 2: PC, ALU, instruction and data memory</figcaption></figure><p>Since this is a pipelined machine, before we wire everything up, we need to think about what stage we want each component to be used in. Each instruction will propagate through all five stages of the pipeline: instruction fetch (<code>IF</code>), instruction decode (<code>ID</code>), address generation/execute (<code>AGEX</code>), memory access (<code>M</code>), and writeback (<code>WB</code>). Since an instruction can only occupy one stage at a time, we need a way to keep track of data and control signals for each instruction as it traverses the pipeline stages. We will place registers between each stage that will store whatever information an instruction may need as it is processed. Now, whenever we want to place a component into the datapath, we need to consider what stage it would best belong in.<p>We know that the instruction memory must be accessed using the address in the PC during <code>IF</code>, so we will place them there. The register file will need to be accessed in <code>ID</code> so that source registers are ready to be accessed by the <code>AGEX</code> stage. The data memory will obviously need to be accessed during the <code>M</code> stage.<figure><img src=pipelineRegs.png><figcaption>Each of the aforementioned components closest to the pipeline registers they will access the most</figcaption></figure><p>Now we will go through each pipeline stage and add whatever components are needed to support every instruction in the RV32I instruction set.<h1 id=fetch>Fetch</h1><p>The fetch stage is mostly already mostly done. The PC simply requests the I-cache for whatever instruction is at the PC's address. The I-cache retrieves the instruction and latches it into the <code>IF/ID</code> register. Additionally, the PC must update each with each instruction. In most cases it is simply incremented by 4, but branch and jump instructions will cause the PC to take another value. For this reason, we need to mux in all its possible next values. The target addressses for branches and <code>jal</code> are computed the same way, so those can share a mux input, and <code>jalr</code> will use the ALU output, so that will also need its own mux input.<p>Now we can update the PC, however the PC does <em>not</em> change every cycle. As we will discuss in the next blog, there are cases where pipeline stages may stall. When this happens, we must not update the PC, hence we need to note that we need a control signal to indicate whether or not the PC should be updated in a cycle.<p>And now that I've mentioned stalling, we might as well include some abstract hardware for that too.<figure><img src=IF.png><figcaption>Instruction fetch stage</figcaption></figure><h1 id=decode>Decode</h1><h2 id=control-unit>Control Unit</h2><p>The decode stage takes the instruction fetched from the previous stage and figures out what the rest of the datapath should do with the instruction. Part of this involves producing the appropriate control signals for the instruction. Thus, the control unit belongs in this stage. In our case, the control unit is really just a big ROM where each entry is the set of control signals for a particular type of instruction. Since we don't yet know which control signals are needed, we'll design the datapath components first, assuming the control unit will provide the necessary signals. We'll specify the actual control signal values once the datapath requirements are clear.<h2 id=immediate-generator>Immediate Generator</h2><p>Since the immediate bit derivations are different for each instruction type, the value generation will use separate logic for each type of instruction. Depending on the instruction type, we will then select which decoding scheme we will use for the current instruction. <em>"How will we choose?"</em> you may ask <em><small>(or not)</small></em>. <em>This,</em> is the first place we will need to use a control signal. The control unit will look at the instruction type and determine what the appropriate selector bits for the immediate value mux should be. The correct value will come out of the mux and be latched into the <code>ID/AGEX</code> register.<p>As for the implementation, it's just a matter of checking the opcode and then bit swizzling everything together, then sign extending:<table><thead><tr><th>Instruction Type<th>Expression<tbody><tr><td>I-type<td><code>{ {20{inst[31]}}, inst[31:20] }</code><tr><td>S-type<td><code>{ {20{inst[31]}}, inst[31:25], inst[11:7] }</code><tr><td>B-type<td><code>{ {19{inst[31]}}, inst[31], inst[7], inst[30:25], inst[11:8], 1'b0 }</code><tr><td>U-type<td><code>{ inst[31:12], 12'h000 }</code><tr><td>J-type<td><code>{ {11{inst[31]}}, inst[31], inst[19:12], inst[20], inst[30:21], 1'b0 }</code></table><h2 id=register-file>Register File</h2><p>Since RISC-V formats all its instruction types in a way such that the addresses of the source and destination registers are always in the same bit fields, pulling data out of the register file is trivial. To get our source registers, we simply need to get <code>IR[19:5]</code> for <code>rs1</code> and <code>IR[24:20]</code> for <code>rs2</code>. By the end of the clock cycle, these registers should be fetched and latched in for the <code>AGEX</code> stage. As for the destination register, whatever instruction is currently in the decode stage is not going to be ready to write back results just yet. In fact, the instructions that are ready to write back results will be those in the <code>WB</code> stage. Because of this, we're not going to connect <code>we</code> or any of the <code>rd</code> inputs quite yet. We'll come back to this later once we hit a stage where instructions are ready to write back their results.<figure><img src=ID.png><figcaption>Instruction decode stage</figcaption></figure><h1 id=address-generation-execute>Address Generation/Execute</h1><p>Like the name suggests, this stage does a few things, including:<ol><li>computing results for arithemic and logical operations<li>generating target addresses for memory accesses and branch/jump targets<li>producing conditional flags</ol><h2 id=execution>Execution</h2><p>In Part 2, we discussed everything the ALU does. All of that happens here. All we have to do is determine what the ALU's operands are and wire it up. Most instructions will simply involve using two source registers. In these cases, <code>ALU_A</code> and <code>ALU_B</code> will be <code>rs1</code> and <code>rs2</code>, respectfully.<br> However, that is not all. I and U-type instructions use immediate values instead of <code>rs2</code>, so that will need to be muxed. Additionally, the <code>auipc</code> instruction uses the PC instead of <code>rs1</code>, so that will also need to be muxed.<h2 id=address-generation>Address Generation</h2><p>All address generation comes from adding the PC with an offset which comes from the instruction's given immediate value. Since our immediate values were decoded and generated in the <code>ID</code> phase, they are ready to use in the <code>AGEX</code> stage. We can trivially pull the immediate values values from the <code>ID/AGEX</code> registers and then add that to the PC to get the correct PC offset. This is the target address for branches, jumps, and memory loads/stores.<p>The <code>jalr</code> instruction is unique in that its target address comes from adding an immediate value to a source register, meaning its address generation must come from the ALU if we don't want to add more hardware. Additionally, RV32I requires that addresses generated by the <code>jalr</code> instruction are half-word aligned, so the last bit must be 0. This is due to maintaining compatibility with RV32C-capable machines.<h2 id=condition-codes-flags>Condition Codes/Flags</h2><p>To determine whether or not a branch should be taken, <code>rs1</code> and <code>rs2</code> are compared according to what we mentioned in Part 2. Recall that when we made the ALU, the primary output was the result of the arithmetic or logical operation. But the secondary outputs were the <code>zero</code>, <code>lt</code> and <code>ltU</code> signals. We will use these as discussed in Part 2, along with another control signal to generate the PCMUX signal used in the <code>IF</code> stage. The reason we need another signal is because of the jump instructions. Since they are unconditional, we need a way to change our address no matter what.<h2 id=control-hazard>Control Hazard</h2><p>Because it takes until the <code>AGEX</code> stage to determine what the next PC should be, this introduces what is called a hazard: What do we do with the two instructions fetched immediately after a jump or branch? We need a way to tell our machine to ignore those instructions in case the wrong instructions were fetched. This is a control hazard and will be handled later in Part 4 after we have a mostly complete control unit. This is because we want to have the entire big picture in mind when managing hazards.<figure><img src=AGEX.png><figcaption>Address generate/execute stage</figcaption></figure><h1 id=memory-access>Memory Access</h1><p>The memory stage of the pipeline is quite simple in terms of hardware with our level of abstraction. We only need to supply the data memory unit with an address and some control signals for write accesses. If the current instruction is a load instruction, then the data of whatever is at the supplied address must be latched for the <code>WB</code> stage.<p>We'll also need a control signal to ensure that accesses are processed in an appropriate manner for the right data size for each instruction.<p>Additionally, since memory can take several cycles to be ready, we will need to ensure that we know whether or not we are ready to move the instruction to the next stage yet or if we need to wait a little longer for the memory to be ready.<figure><img src=M.png><figcaption>Memory access stage</figcaption></figure><h1 id=writeback>Writeback</h1><p>This is arguably the simplest pipeline stage, as all it does is write whatever needs to be written into whatever register needs to be changed, given that the instruction does need to write something to a register.<p>Many instructions will compute something with the ALU during <code>AGEX</code> and then write that result into <code>rd</code>, whose address is given by the instruction. Load instructions will use the retrieved data from <code>M</code>, and jump instructions will store the return linkage into <code>rd</code>.<figure><img src=WB.png><figcaption>Writeback stage</figcaption></figure><h1 id=putting-it-all-together>Putting It All Together</h1><p>Now that we have our individual stages, it is time to connect them all! We're now halfway done with the CPU. All that's left now is determining control signals and creating the control unit. After that, we need to consider hazards and then test the design by hand-tracing all the RV32I instructions as a final verification step before we begin the implementation for an FPGA.<figure><p><img alt decoding=async loading=lazy src=https://samienr.com/blog/designing-a-cpu-03/datapath.png#full-bleed><figcaption>Our (mostly) complete pipeline datapath</figcaption></figure></article><hr><nav id=post-nav><a class="post-nav-item post-nav-prev" href=https://samienr.com/blog/designing-a-cpu-02/> <div class=nav-arrow>Previous</div> <span class=post-title>Designing a CPU From Scratch, Part 2: Fundamental Components</span> </a></nav><span class=hidden id=copy-code-text>Copy Code</span><span class=hidden id=search-index>https://samienr.com/search_index.en.json</span><span class=hidden id=more-matches-text>$MATCHES more matches</span></main><footer id=site-footer><nav><ul><li><a href=https://samienr.com/tags/projects>Projects</a><li><a href=https://samienr.com/notebook/>Notebook</a><li><a href=https://samienr.com/resume/>Resume</a></ul></nav><p>© samienr, 2025</footer>