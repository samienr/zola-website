<!doctype html><html lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta content="Electrical Nerd + Digital Artist" name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content="rgb(101, 143, 239)" name=theme-color><meta content="rgb(140, 170, 238)" media=(prefers-color-scheme:dark) name=theme-color><title>Designing a CPU From Scratch, Part 2: Fundamental Components - samienr</title><link href=https://samienr.com/blog/designing-a-cpu-02/ rel=canonical><link href=https://samienr.com/favicon.png rel=icon type=image/png><link href=https://samienr.com/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><link title="samienr - RSS Feed" href=https://samienr.com/rss.xml rel=alternate type=application/rss+xml><link title="samienr - Atom Feed" href=https://samienr.com/atom.xml rel=alternate type=application/atom+xml><style>:root{--accent-color:#658fef}[data-theme=dark]{--accent-color:#8caaee}@media (prefers-color-scheme:dark){:root:not([data-theme=light]){--accent-color:#8caaee}}</style><link href=https://samienr.com/style.css rel=stylesheet><link href=https://samienr.com/footer.css rel=stylesheet><link href=https://samienr.com/typography.css rel=stylesheet><link href=https://samienr.com/notebook.css rel=stylesheet><script defer src=https://samienr.com/closable.js></script><script defer src=https://samienr.com/copy-button.js></script><script defer src=https://samienr.com/elasticlunr.min.js></script><script defer src=https://samienr.com/search-elasticlunr.js></script><script defer src=https://samienr.com/theme-switcher.js></script><meta content=samienr property=og:site_name><meta content="Designing a CPU From Scratch, Part 2: Fundamental Components - samienr" property=og:title><meta content=https://samienr.com/blog/designing-a-cpu-02/ property=og:url><meta content="Understanding RV32I instructions and implementing the most basic hardware" property=og:description><meta content=https://samienr.com/card.png property=og:image><meta content=en_US property=og:locale><body><header id=site-nav><nav><a href=#main-content tabindex=0> Skip to Main Content </a><ul><li id=home><a href=https://samienr.com> <i class=icon></i>samienr</a><li class=divider><li><a href=https://samienr.com/blog/>Blog</a><li><a href=https://samienr.com/photography/>Photography</a><li><a href=https://samienr.com/contact/>Contact</a><li id=search><button class=circle id=search-toggle title=Search><i class=icon></i></button><li id=theme-switcher><details class=closable><summary class=circle title=Theme><i class=icon></i></summary> <ul><li><button title="Switch to Light Theme" class=circle id=theme-light><i class=icon></i></button><li><button title="Switch to Dark Theme" class=circle id=theme-dark><i class=icon></i></button><li><button title="Use System Theme" class=circle id=theme-system><i class=icon></i></button></ul></details><li id=feed><details class=closable><summary class=circle title=Feed><i class=icon></i></summary> <ul><li><a href=https://samienr.com/rss.xml>RSS</a><li><a href=https://samienr.com/atom.xml>Atom</a></ul></details></ul></nav><div id=search-container><label class=visually-hidden for=search-bar>Search</label><input placeholder="Search for…" autocomplete=off disabled id=search-bar type=search><div id=search-results-container><div id=search-results></div></div></div></header><main id=main-content><div id=breadcrumb-container><a class=breadcrumb-path href=/>Home</a><span class=breadcrumb-separator> > </span><a class=breadcrumb-path href=https://samienr.com/blog/>Blog</a><span class=breadcrumb-separator> > </span><a class="breadcrumb-path active" id=active-page>Designing a CPU From Scratch, Part 2: Fundamental Components</a></div><article><div id=heading><p><small> <time datetime=" 2025-12-19T00:00:00+00:00">Published on December 19, 2025</time></small><h1>Designing a CPU From Scratch, Part 2: Fundamental Components</h1><p><small><span>5 minutes read</span><span> • </span></small><ul class=tags><li><a class=tag href=https://samienr.com/tags/projects/>Projects</a><li><a class=tag href=https://samienr.com/tags/computer-architecture/>Computer Architecture</a><li><a class=tag href=https://samienr.com/tags/designing-a-cpu/>Designing a CPU</a></ul></div><div id=buttons-container><a title="Go to Top" href=#top id=go-to-top><i class=icon></i></a><a title="File an Issue" href=https://github.com/samienr/zola-website/issues id=issue><i class=icon></i></a></div><h1 id=arithmetic-logic-unit-alu>Arithmetic Logic Unit (ALU)</h1><p>After skimming through the RV32I instruction set, I figured I could start with the arithmetic logic unit (ALU). The ALU is where most actual computations happen. Its composition depends on what operations it needs to perform. For RV32I, these are the operations I will need to implement for a functional ALU:<table><thead><tr><th>Instruction<th>ALU Unit Needed<tbody><tr><td><code>add</code>, <code>addi</code><td>Adder<tr><td><code>sub</code>, <code>slt</code>, <code>sltu</code><td>Subtractor<tr><td><code>slli</code>, <code>srli</code>, <code>srai</code>, <code>sll</code>, <code>sra</code>, <code>srl</code><td>Shifter<tr><td><code>and</code>, <code>or</code>, <code>xor</code>, <code>andi</code>, <code>ori</code>, <code>xori</code><td>Primitive logic gates</table><p>Our design will simply have circuitry to compute all these operations and then multiplex out whatever an <code>ALU_Op</code> control signal requests.<p>I'm aware that there are some other instructions that do math, such as <code>auipc</code> and <code>lui</code>. These operations will use their own dedicated hardware outside of the ALU.<h2 id=condition-codes-flags>Condition Codes/Flags</h2><p>In addition to the operations, our machine also needs to generate condition flags. RV32I doesn't really define how we will handle whether branches are taken or not, so how we approach this is up to us. The simplest approach I found was only checking for three conditions:<ol><li>Is our result zero?<li>Is A &lt; B? (unsigned)<li>Is A &lt; B? (signed)</ol><p>We can easily use the results of the subtractor for these signals. Every type of branch instruction we will need to consider can be resolved using these three conditions.<table><thead><tr><th>Instruction<th>Logical Condition<th>Alu Signal<tbody><tr><td>beq<td>A == B<td>Zero<tr><td>bne<td>A != B<td>NOT Zero<tr><td>bltu<td>A &lt; B (unsigned)<td>A &lt; B (unsigned)<tr><td>bgeu<td>A >= B (unsigned)<td>NOT A &lt; B (unsigned)<tr><td>blt<td>A &lt; B (signed)<td>A &lt; B (signed)<tr><td>bge<td>A >= B (signed)<td>NOT A &lt; B (signed)</table><p>The <code>zero</code> condition will simply check if A and B are equal to each other.<br> The less than (unsigned) condition <code>ltU</code> will be computed by subtracting <code>A - B</code> and taking the complement of the subtractor's borrow bit.<br> The less than (signed) condition <code>lt</code> will use the same subtractor and result. Its value will come from the <code>XOR</code> of the subtractor's borrow bit and another signal that indicates whether or not the subtractor had overflow.<h2 id=code>Code</h2><pre class=language-verilog data-lang=verilog style=color:#ccc9c2;background-color:#212733><code class=language-verilog data-lang=verilog><span style=color:#ffa759>module </span><span style=color:#73d0ff>ALU</span><span>(
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] </span><span style=color:#fc6>A</span><span>,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] </span><span style=color:#fc6>B</span><span>,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>3</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] ALU_Op,
</span><span>    </span><span style=color:#5ccfe6;font-style:italic>output </span><span style=color:#ffa759>reg</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] Result,
</span><span style=color:#5ccfe6;font-style:italic>    output</span><span> zero, lt, ltU
</span><span>    );
</span><span>
</span><span style=color:#ffa759>wire</span><span> [</span><span style=color:#fc6>32</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] sub_full </span><span style=color:#f29e74>= {</span><span style=color:#fc6>1'b0</span><span>, </span><span style=color:#fc6>A</span><span style=color:#f29e74>} - {</span><span style=color:#fc6>1'b0</span><span>, </span><span style=color:#fc6>B</span><span style=color:#f29e74>}</span><span>;
</span><span style=color:#ffa759>wire</span><span> sub_overflow </span><span style=color:#f29e74>=</span><span> (</span><span style=color:#fc6>A</span><span>[</span><span style=color:#fc6>31</span><span>] </span><span style=color:#f29e74>^ </span><span style=color:#fc6>B</span><span>[</span><span style=color:#fc6>31</span><span>]) </span><span style=color:#f29e74>&</span><span> (sub_full[</span><span style=color:#fc6>31</span><span>] </span><span style=color:#f29e74>^ </span><span style=color:#fc6>A</span><span>[</span><span style=color:#fc6>31</span><span>]);
</span><span>
</span><span style=color:#ffa759>assign</span><span> zero </span><span style=color:#f29e74>= </span><span style=color:#fc6>A </span><span style=color:#f29e74>== </span><span style=color:#fc6>B</span><span>;
</span><span style=color:#ffa759>assign</span><span> lt  </span><span style=color:#f29e74>=</span><span> sub_full[</span><span style=color:#fc6>31</span><span>] </span><span style=color:#f29e74>^</span><span> sub_overflow;
</span><span style=color:#ffa759>assign</span><span> ltU </span><span style=color:#f29e74>= ~</span><span>sub_full[</span><span style=color:#fc6>32</span><span>];
</span><span>
</span><span style=color:#ffa759>always </span><span style=color:#f29e74>@</span><span>(</span><span style=color:#f29e74>*</span><span>)
</span><span style=color:#ffa759>begin
</span><span>Result </span><span style=color:#f29e74>= </span><span style=color:#fc6>32'b0</span><span>;
</span><span>    </span><span style=color:#ffa759>case</span><span> (ALU_Op)
</span><span>        </span><span style=color:#fc6>`ALU_ADD</span><span style=color:#f29e74>:</span><span>       Result </span><span style=color:#f29e74>= </span><span style=color:#fc6>A </span><span style=color:#f29e74>+ </span><span style=color:#fc6>B</span><span>;
</span><span>        </span><span style=color:#fc6>`ALU_SUB</span><span style=color:#f29e74>:</span><span>       Result </span><span style=color:#f29e74>=</span><span> sub_full[</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>];
</span><span>        </span><span style=color:#fc6>`ALU_SHF_L</span><span style=color:#f29e74>:</span><span>     Result </span><span style=color:#f29e74>= </span><span style=color:#fc6>A </span><span style=color:#f29e74>&lt;&lt; </span><span style=color:#fc6>B</span><span>[</span><span style=color:#fc6>4</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>];
</span><span>        </span><span style=color:#fc6>`ALU_SHF_R_L</span><span style=color:#f29e74>:</span><span>   Result </span><span style=color:#f29e74>= </span><span style=color:#fc6>A </span><span style=color:#f29e74>>> </span><span style=color:#fc6>B</span><span>[</span><span style=color:#fc6>4</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>];
</span><span>        </span><span style=color:#fc6>`ALU_SHF_R_A</span><span style=color:#f29e74>:</span><span>   Result </span><span style=color:#f29e74>= </span><span style=color:#f28779>$signed</span><span>(</span><span style=color:#fc6>A</span><span>) </span><span style=color:#f29e74>>>> </span><span style=color:#fc6>B</span><span>[</span><span style=color:#fc6>4</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>];
</span><span>        </span><span style=color:#fc6>`ALU_AND</span><span style=color:#f29e74>:</span><span>       Result </span><span style=color:#f29e74>= </span><span style=color:#fc6>A </span><span style=color:#f29e74>& </span><span style=color:#fc6>B</span><span>;
</span><span>        </span><span style=color:#fc6>`ALU_OR</span><span style=color:#f29e74>:</span><span>        Result </span><span style=color:#f29e74>= </span><span style=color:#fc6>A </span><span style=color:#f29e74>| </span><span style=color:#fc6>B</span><span>;
</span><span>        </span><span style=color:#fc6>`ALU_XOR</span><span style=color:#f29e74>:</span><span>       Result </span><span style=color:#f29e74>= </span><span style=color:#fc6>A </span><span style=color:#f29e74>^ </span><span style=color:#fc6>B</span><span>;
</span><span>        </span><span style=color:#fc6>`ALU_PASSB</span><span style=color:#f29e74>:</span><span>     Result </span><span style=color:#f29e74>= </span><span style=color:#fc6>B</span><span>;
</span><span>        </span><span style=color:#fc6>`ALU_SLT</span><span style=color:#f29e74>:</span><span>       Result </span><span style=color:#f29e74>= {{</span><span style=color:#fc6>31</span><span style=color:#f29e74>{</span><span style=color:#fc6>1'b0</span><span style=color:#f29e74>}}</span><span>, lt</span><span style=color:#f29e74>}</span><span>;
</span><span>        </span><span style=color:#fc6>`ALU_SLTU</span><span style=color:#f29e74>:</span><span>      Result </span><span style=color:#f29e74>= {{</span><span style=color:#fc6>31</span><span style=color:#f29e74>{</span><span style=color:#fc6>1'b0</span><span style=color:#f29e74>}}</span><span>, ltU</span><span style=color:#f29e74>}</span><span>;
</span><span>    </span><span style=color:#ffa759>endcase
</span><span style=color:#ffa759>end
</span><span style=color:#ffa759>endmodule
</span></code></pre><h1 id=register-file>Register File</h1><p>This is one of the most trivial yet most important components to make. Since we won't be doing anything superscalar or out-of-order just yet, we can get away with writing a very simple register file with just two read ports and one write port. Our ISA tells us that we have 32 registers with 32 bits each. Since reading doesn't change state, we can make that part combinational and save some time. However, since writing does change state, it must be synchronized, so changes will only be made on rising clock edges. Other than that, the only thing we need to keep in mind is that the x0 register (address 0b00000) is always 0, and writing to it makes no changes.<p><strong>EDIT:</strong> Looks like I missed something here. Since this machine is going to be pipelined, we need to account for the case where one register is being written by one instruction, but is simultaneously being read by a future instruction in an earlier phase of the pipeline. In this case, the value that is being written must be forwarded to the next instruction, <em>not</em> the value that was there before. To fix this, all we need is the ability to directly output what is being written if the destination register happens to be one of the source registers.<h2 id=code-1>Code</h2><pre class=language-verilog data-lang=verilog style=color:#ccc9c2;background-color:#212733><code class=language-verilog data-lang=verilog><span style=color:#ffa759>module </span><span style=color:#73d0ff>RegFile</span><span>(
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> clk,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>4</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] rs1,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>4</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] rs2,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> we,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>4</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] wr_addr,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] wr_data,
</span><span style=color:#5ccfe6;font-style:italic>    output</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] rd1,
</span><span style=color:#5ccfe6;font-style:italic>    output</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] rd2
</span><span>    );
</span><span>    
</span><span style=color:#ffa759>    reg</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] registers[</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>];
</span><span>
</span><span>    </span><span style=color:#ffa759>always </span><span style=color:#f29e74>@</span><span>(</span><span style=color:#ffa759>posedge</span><span> clk)
</span><span>        </span><span style=color:#ffa759>if</span><span> (we </span><span style=color:#f29e74>&&</span><span> wr_addr </span><span style=color:#f29e74>!= </span><span style=color:#fc6>5'b0</span><span>)
</span><span>            registers[wr_addr] </span><span style=color:#f29e74>&lt;=</span><span> wr_data;
</span><span>
</span><span>    </span><span style=color:#ffa759>assign</span><span> rd1 </span><span style=color:#f29e74>=</span><span> (rs1 </span><span style=color:#f29e74>== </span><span style=color:#fc6>0</span><span>) </span><span style=color:#f29e74>? </span><span style=color:#fc6>32'b0 </span><span style=color:#f29e74>: </span><span style=color:#5c6773;font-style:italic>// read x0
</span><span>                 (rs1 </span><span style=color:#f29e74>==</span><span> wr_addr </span><span style=color:#f29e74>&&</span><span> we) </span><span style=color:#f29e74>?</span><span> wr_data </span><span style=color:#f29e74>: </span><span style=color:#5c6773;font-style:italic>// bypass
</span><span>                 registers[rs1]; </span><span style=color:#5c6773;font-style:italic>// normal read
</span><span>
</span><span>    </span><span style=color:#ffa759>assign</span><span> rd2 </span><span style=color:#f29e74>=</span><span> (rs2 </span><span style=color:#f29e74>== </span><span style=color:#fc6>0</span><span>) </span><span style=color:#f29e74>? </span><span style=color:#fc6>32'b0 </span><span style=color:#f29e74>:
</span><span>                 (rs2 </span><span style=color:#f29e74>==</span><span> wr_addr </span><span style=color:#f29e74>&&</span><span> we) </span><span style=color:#f29e74>?</span><span> wr_data </span><span style=color:#f29e74>:
</span><span>                 registers[rs2];
</span><span style=color:#ffa759>endmodule
</span></code></pre><h1 id=program-counter-pc>Program Counter (PC)</h1><p>Even more trivial than the register file is the PC. The PC is a simple 32-bit register that can be updated every cycle. In real hardware, this would be driven by some reset logic or a boot ROM.<h2 id=code-2>Code</h2><pre class=language-verilog data-lang=verilog style=color:#ccc9c2;background-color:#212733><code class=language-verilog data-lang=verilog><span style=color:#ffa759>module </span><span style=color:#73d0ff>PC</span><span>(
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> clk,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> we,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] in,
</span><span style=color:#5ccfe6;font-style:italic>    output</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] out
</span><span>    );
</span><span>    
</span><span style=color:#ffa759>    reg</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] counter;
</span><span>    </span><span style=color:#ffa759>initial</span><span> counter </span><span style=color:#f29e74>= </span><span style=color:#fc6>32'h8000_0000</span><span>;
</span><span>    </span><span style=color:#ffa759>assign</span><span> out </span><span style=color:#f29e74>=</span><span> counter;
</span><span>    </span><span style=color:#ffa759>always </span><span style=color:#f29e74>@</span><span>(</span><span style=color:#ffa759>posedge</span><span> clk)
</span><span>        </span><span style=color:#ffa759>if</span><span> (we) counter </span><span style=color:#f29e74>&lt;=</span><span> in;
</span><span>    
</span><span style=color:#ffa759>endmodule
</span></code></pre><h1 id=memory>Memory</h1><p>Even though RISC-V architecturally has instruction and data memory unified, I'm going to keep instructions and data separate in hardware as it makes pipelining much less of a headache. They're usually cached separately in most machines anyways.<h2 id=instructions>Instructions</h2><p>We will make the instruction memory behave like a synchronous ROM. We'll also ensure that it is only word addressable.<pre class=language-verilog data-lang=verilog style=color:#ccc9c2;background-color:#212733><code class=language-verilog data-lang=verilog><span style=color:#5c6773;font-style:italic>// TODO: Add simulated delay
</span><span>
</span><span style=color:#ffa759>module </span><span style=color:#73d0ff>InstructionMemory</span><span>(
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> clk,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] addr,
</span><span>    </span><span style=color:#5ccfe6;font-style:italic>output </span><span style=color:#ffa759>reg</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] instruction
</span><span>    );
</span><span style=color:#ffa759>    reg</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] mem [</span><span style=color:#fc6>0</span><span style=color:#f29e74>:</span><span style=color:#fc6>1023</span><span>]; </span><span style=color:#5c6773;font-style:italic>// 4KB Instruction Memory (1024 words)
</span><span style=color:#5c6773;font-style:italic>// TODO: load test program    
</span><span style=color:#5c6773;font-style:italic>//    initial $readmemh("program.hex", mem);
</span><span>
</span><span>    </span><span style=color:#ffa759>always </span><span style=color:#f29e74>@</span><span>(</span><span style=color:#ffa759>posedge</span><span> clk)
</span><span>        instruction </span><span style=color:#f29e74>&lt;=</span><span> mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>2</span><span>]]; </span><span style=color:#5c6773;font-style:italic>// chop off last two bits to ensure word aligned
</span><span>        
</span><span style=color:#ffa759>endmodule
</span></code></pre><h2 id=data>Data</h2><p>Data memory is a little more complicated as we need to be able to operate on bytes, halfwords, and words for stores. I'm just going to model this internally as an array of 8-bit registers. The input and output will be in terms of words, and a <code>byte_en</code> signal will determine how many bytes are actually going into memory.<pre class=language-verilog data-lang=verilog style=color:#ccc9c2;background-color:#212733><code class=language-verilog data-lang=verilog><span style=color:#5c6773;font-style:italic>// word aligned accesses only from core's POV, internally byte addresable
</span><span style=color:#ffa759>module </span><span style=color:#73d0ff>DMem</span><span>(
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> clk,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> we,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>3</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] byte_en,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] addr,
</span><span style=color:#5ccfe6;font-style:italic>    input</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] din,
</span><span>    </span><span style=color:#5ccfe6;font-style:italic>output </span><span style=color:#ffa759>reg</span><span> [</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] dout,
</span><span style=color:#5ccfe6;font-style:italic>    output</span><span> ready
</span><span>    );
</span><span>    
</span><span>    </span><span style=color:#ffa759>assign</span><span> ready </span><span style=color:#f29e74>= </span><span style=color:#fc6>1'b1</span><span>; </span><span style=color:#5c6773;font-style:italic>// TODO: simulate delay
</span><span>    
</span><span style=color:#ffa759>    reg</span><span> [</span><span style=color:#fc6>7</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] mem[</span><span style=color:#fc6>0</span><span style=color:#f29e74>:</span><span style=color:#fc6>4095</span><span>]; </span><span style=color:#5c6773;font-style:italic>// 4KB addressable
</span><span>    
</span><span>    </span><span style=color:#ffa759>always </span><span style=color:#f29e74>@</span><span>(</span><span style=color:#ffa759>posedge</span><span> clk) </span><span style=color:#ffa759>begin
</span><span>        dout </span><span style=color:#f29e74>&lt;= {</span><span>mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] </span><span style=color:#f29e74>+ </span><span style=color:#fc6>3</span><span>], 
</span><span>                 mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] </span><span style=color:#f29e74>+ </span><span style=color:#fc6>2</span><span>], 
</span><span>                 mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] </span><span style=color:#f29e74>+ </span><span style=color:#fc6>1</span><span>], 
</span><span>                 mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>]]</span><span style=color:#f29e74>}</span><span>;
</span><span>        </span><span style=color:#ffa759>if</span><span> (we) </span><span style=color:#ffa759>begin
</span><span>            </span><span style=color:#ffa759>if</span><span> (byte_en[</span><span style=color:#fc6>0</span><span>]) mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>]] </span><span style=color:#f29e74>&lt;=</span><span> din[</span><span style=color:#fc6>7</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>];
</span><span>            </span><span style=color:#ffa759>if</span><span> (byte_en[</span><span style=color:#fc6>1</span><span>]) mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] </span><span style=color:#f29e74>+ </span><span style=color:#fc6>1</span><span>] </span><span style=color:#f29e74>&lt;=</span><span> din[</span><span style=color:#fc6>15</span><span style=color:#f29e74>:</span><span style=color:#fc6>8</span><span>];
</span><span>            </span><span style=color:#ffa759>if</span><span> (byte_en[</span><span style=color:#fc6>2</span><span>]) mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] </span><span style=color:#f29e74>+ </span><span style=color:#fc6>2</span><span>] </span><span style=color:#f29e74>&lt;=</span><span> din[</span><span style=color:#fc6>23</span><span style=color:#f29e74>:</span><span style=color:#fc6>16</span><span>];
</span><span>            </span><span style=color:#ffa759>if</span><span> (byte_en[</span><span style=color:#fc6>3</span><span>]) mem[addr[</span><span style=color:#fc6>11</span><span style=color:#f29e74>:</span><span style=color:#fc6>0</span><span>] </span><span style=color:#f29e74>+ </span><span style=color:#fc6>3</span><span>] </span><span style=color:#f29e74>&lt;=</span><span> din[</span><span style=color:#fc6>31</span><span style=color:#f29e74>:</span><span style=color:#fc6>24</span><span>];
</span><span>        </span><span style=color:#ffa759>end
</span><span>    </span><span style=color:#ffa759>end
</span><span>    
</span><span style=color:#ffa759>endmodule
</span></code></pre><h1 id=what-s-next>What's Next?</h1><p>Now we have the most basic components, we are ready to think about how we will decode instructions and wire the datapath. That will involve creating the control signals, logic relating to control signals, smaller intermediate components depending on what instructions need, and the pipeline registers. After we do that, all that should be left is hazard control, handling branches, and testing.<p>For now, feel free to take a look at the <a href=https://github.com/samienr/risc-v-toy>source HDL code I have so far on my GitHub.</a> Until then, take care!</article><hr><nav id=post-nav><a class="post-nav-item post-nav-prev" href=https://samienr.com/blog/designing-a-cpu-01/> <div class=nav-arrow>Previous</div> <span class=post-title>Designing a CPU From Scratch, Part 1: ISA</span> </a></nav><span class=hidden id=copy-code-text>Copy Code</span><span class=hidden id=search-index>https://samienr.com/search_index.en.json</span><span class=hidden id=more-matches-text>$MATCHES more matches</span></main><footer id=site-footer><nav><ul><li><a href=https://samienr.com/tags/projects>Projects</a><li><a href=https://samienr.com/notebook/>Notebook</a><li><a href=https://samienr.com/resume/>Resume</a></ul></nav><p>© samienr, 2025</footer>